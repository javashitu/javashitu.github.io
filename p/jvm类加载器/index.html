<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="学习背景 关于垃圾回收器的知识我们讲完了，今天开始我们讲一个JVM里也很重要的概念，类加载器。类加载器可以说是JVM的入口也不为过，而且是面试里非常高频的问点，可以和垃圾回收器并列。几乎是把把问的程度，大家要好好看好好学。\n类加载步骤 我们可以从类的加载步骤来考察类加载器的功能，类从进入JVM内存开始到卸载，生命周期总共经过5步\nloading(加载) 这一步需要做的是通过类的全限定名称获取类的二进制流，将字节流所代表的静态存储结构转换为方法区的运行时数据结构，在方法区中生成这个类的class对象，作为方法区中这个类的各种数据的访问入口。也正是因为这一步没有规定读取二进制流的来源是什么，因此诞生了很多后续的技术，比如从压缩包中读取，就变成了JAR,WAR,EAR等格式，从网络中读取就发展成了Applet(运行在浏览器中的java程序，已经被淘汰)，还有JSP,和一些中间件服务器。最有生命力的则是动态代理技术。 而且，也只有这个阶段用户可以自定义一些操作来参与到类的加载过程，后面的过程全是虚拟机主导的。\nlinking(链接),链接这一步包含3个步骤\nVerfication(验证) 验证是为了保证class文件安全，不会产生危害JVM的安全，存粹的java语言是不会产生不安全的操作的，比如访问数组边界外的数据，跳转到不存在的代码。但是JVM没有要求class文件的产生途径，我们甚至可以用16进制文本编辑器来编写java文件。所以验证时很重要的，具体的验证规则和验证的时机是直到JDK1.7的JAVA虚拟机规范才具体起来的。\nPreparation(准备) 这个阶段会正式为类变量分配内存并且设定初始值，需要注意的是这里只分配了类变量(static修饰的)，实例变量是没有分配的(实例变量会在初始化时一起分配在堆中)。还有就是类变量一开始会被分配为默认值，实际赋值是在编译后的(这个方法是类的构造方法，收集类的信息，比静态变量值)方法中。比如\nstatic int num = 123;\n那么在准备阶段会被分配为0，在初始化时才会被分配为123。但也有特殊，常量(static final)则会直接被初始化为指定的值。\nResolution(解析) 解析是将常量池中的符号引用替换为直接引用的过程。符号引用是一组描述被引用目标的符号，可以是任何形式的字面量，引用的目标不一定要存在于内存中。直接引用则是指针，相对偏移量或者句柄，直接引用一般是和虚拟机内存布局相关的。\nInitialization(初始化) 初始化是类加载过程的最后一步，到了初始化阶段，就是实际执行程序员编写的代码的步骤。初始化阶段主要是执行方法。JVM会保证父类的方法优先于子类执行，而且多线程环境下也会保证线程安全，当多个线程初始化一个类时，则会只有一个线程去执行方法，这意味着当静态代码块中有比较耗时的操作时，在多线程初始化时有可能造成阻塞。 clinit是将所有的类变量(静态变量)和静态语句(static代码块)的代码合并收集来的。收集的顺序是按照代码顺序，需要注意的是静态代码块的只能访问定义在它之前的静态变量，定义在它之后的变量可以赋值，但是不能访问。再额外说一下，类变量必须有赋值才会被收集为clinit方法，如果只是声明了类变量,比如static int a;那么这个类其实不会生成clinit方法，常量也不会被收集到clinit方法。\nUsing(使用)\nUnloading(卸载)\n一般的加载顺序是按照这五步进行的。需要注意的是，为了支持JAVA语言的运行时绑定，解析的 步骤有可能在初始化之后，这种操作一般被称为动态绑定或者晚绑定。而且，加载类的时机JVM也没规定，但是规定了初始化必须在加载之后，即加载，验证，准备必须在初始化之前。而且严格规定了初始化的执行时机，总共6种，且只有这六种。其他的时机JVM可以自己定义。\n读取到new指令，访问静态final字段时 使用refect包对类进行反射时，如果类没有初始化一定要先初始化 初始化一个类时，如果父类没有初始化先初始化父类(这条规则对接口无效，接口则是允许不初始化父接口，只有使用到父接口时才初始化) JVM启动时必须指定主类，这个主类必须最先初始化 JDK1.7下的Invoke.MethodHandler解析出的类没有经过初始化必须先初始化 JDK1.8以后得接口里使用了default方法时，如果这个接口的实现类发生了变化，那么该接口要在类被初始化之前初始化 举一个简单的例子\n父类\n子类\n下面的代码在执行的时候只会输出&quot;superclass init&quot;，因为只有父类是被初始化了的，虽然是静态引用，但是父类也会初始化。静态变量在编译器编译完成阶段就会被加载到当前类的常量池中，完成和引用类的解耦，这里会初始化存粹是因为父类需要初始化。配合这个例子大家可以看一下TestClass2,TestClass3的代码，思考下为什么。\n">
<title>jvm类加载器</title>

<link rel='canonical' href='http://localhost:1313/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/'>

<link rel="stylesheet" href="/scss/style.min.946cca6c6259ef94ac55abfae7c7bf3291ea3ed5eea17ef77500b257217c6710.css"><meta property='og:title' content="jvm类加载器">
<meta property='og:description' content="学习背景 关于垃圾回收器的知识我们讲完了，今天开始我们讲一个JVM里也很重要的概念，类加载器。类加载器可以说是JVM的入口也不为过，而且是面试里非常高频的问点，可以和垃圾回收器并列。几乎是把把问的程度，大家要好好看好好学。\n类加载步骤 我们可以从类的加载步骤来考察类加载器的功能，类从进入JVM内存开始到卸载，生命周期总共经过5步\nloading(加载) 这一步需要做的是通过类的全限定名称获取类的二进制流，将字节流所代表的静态存储结构转换为方法区的运行时数据结构，在方法区中生成这个类的class对象，作为方法区中这个类的各种数据的访问入口。也正是因为这一步没有规定读取二进制流的来源是什么，因此诞生了很多后续的技术，比如从压缩包中读取，就变成了JAR,WAR,EAR等格式，从网络中读取就发展成了Applet(运行在浏览器中的java程序，已经被淘汰)，还有JSP,和一些中间件服务器。最有生命力的则是动态代理技术。 而且，也只有这个阶段用户可以自定义一些操作来参与到类的加载过程，后面的过程全是虚拟机主导的。\nlinking(链接),链接这一步包含3个步骤\nVerfication(验证) 验证是为了保证class文件安全，不会产生危害JVM的安全，存粹的java语言是不会产生不安全的操作的，比如访问数组边界外的数据，跳转到不存在的代码。但是JVM没有要求class文件的产生途径，我们甚至可以用16进制文本编辑器来编写java文件。所以验证时很重要的，具体的验证规则和验证的时机是直到JDK1.7的JAVA虚拟机规范才具体起来的。\nPreparation(准备) 这个阶段会正式为类变量分配内存并且设定初始值，需要注意的是这里只分配了类变量(static修饰的)，实例变量是没有分配的(实例变量会在初始化时一起分配在堆中)。还有就是类变量一开始会被分配为默认值，实际赋值是在编译后的(这个方法是类的构造方法，收集类的信息，比静态变量值)方法中。比如\nstatic int num = 123;\n那么在准备阶段会被分配为0，在初始化时才会被分配为123。但也有特殊，常量(static final)则会直接被初始化为指定的值。\nResolution(解析) 解析是将常量池中的符号引用替换为直接引用的过程。符号引用是一组描述被引用目标的符号，可以是任何形式的字面量，引用的目标不一定要存在于内存中。直接引用则是指针，相对偏移量或者句柄，直接引用一般是和虚拟机内存布局相关的。\nInitialization(初始化) 初始化是类加载过程的最后一步，到了初始化阶段，就是实际执行程序员编写的代码的步骤。初始化阶段主要是执行方法。JVM会保证父类的方法优先于子类执行，而且多线程环境下也会保证线程安全，当多个线程初始化一个类时，则会只有一个线程去执行方法，这意味着当静态代码块中有比较耗时的操作时，在多线程初始化时有可能造成阻塞。 clinit是将所有的类变量(静态变量)和静态语句(static代码块)的代码合并收集来的。收集的顺序是按照代码顺序，需要注意的是静态代码块的只能访问定义在它之前的静态变量，定义在它之后的变量可以赋值，但是不能访问。再额外说一下，类变量必须有赋值才会被收集为clinit方法，如果只是声明了类变量,比如static int a;那么这个类其实不会生成clinit方法，常量也不会被收集到clinit方法。\nUsing(使用)\nUnloading(卸载)\n一般的加载顺序是按照这五步进行的。需要注意的是，为了支持JAVA语言的运行时绑定，解析的 步骤有可能在初始化之后，这种操作一般被称为动态绑定或者晚绑定。而且，加载类的时机JVM也没规定，但是规定了初始化必须在加载之后，即加载，验证，准备必须在初始化之前。而且严格规定了初始化的执行时机，总共6种，且只有这六种。其他的时机JVM可以自己定义。\n读取到new指令，访问静态final字段时 使用refect包对类进行反射时，如果类没有初始化一定要先初始化 初始化一个类时，如果父类没有初始化先初始化父类(这条规则对接口无效，接口则是允许不初始化父接口，只有使用到父接口时才初始化) JVM启动时必须指定主类，这个主类必须最先初始化 JDK1.7下的Invoke.MethodHandler解析出的类没有经过初始化必须先初始化 JDK1.8以后得接口里使用了default方法时，如果这个接口的实现类发生了变化，那么该接口要在类被初始化之前初始化 举一个简单的例子\n父类\n子类\n下面的代码在执行的时候只会输出&quot;superclass init&quot;，因为只有父类是被初始化了的，虽然是静态引用，但是父类也会初始化。静态变量在编译器编译完成阶段就会被加载到当前类的常量池中，完成和引用类的解耦，这里会初始化存粹是因为父类需要初始化。配合这个例子大家可以看一下TestClass2,TestClass3的代码，思考下为什么。\n">
<meta property='og:url' content='http://localhost:1313/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/'>
<meta property='og:site_name' content='javashitu'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='jvm' /><meta property='article:tag' content='类加载器' /><meta property='article:published_time' content='2024-04-04T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2024-04-04T00:00:00&#43;00:00'/><meta property='og:image' content='http://localhost:1313/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/cover.jpg' />
<meta name="twitter:title" content="jvm类加载器">
<meta name="twitter:description" content="学习背景 关于垃圾回收器的知识我们讲完了，今天开始我们讲一个JVM里也很重要的概念，类加载器。类加载器可以说是JVM的入口也不为过，而且是面试里非常高频的问点，可以和垃圾回收器并列。几乎是把把问的程度，大家要好好看好好学。\n类加载步骤 我们可以从类的加载步骤来考察类加载器的功能，类从进入JVM内存开始到卸载，生命周期总共经过5步\nloading(加载) 这一步需要做的是通过类的全限定名称获取类的二进制流，将字节流所代表的静态存储结构转换为方法区的运行时数据结构，在方法区中生成这个类的class对象，作为方法区中这个类的各种数据的访问入口。也正是因为这一步没有规定读取二进制流的来源是什么，因此诞生了很多后续的技术，比如从压缩包中读取，就变成了JAR,WAR,EAR等格式，从网络中读取就发展成了Applet(运行在浏览器中的java程序，已经被淘汰)，还有JSP,和一些中间件服务器。最有生命力的则是动态代理技术。 而且，也只有这个阶段用户可以自定义一些操作来参与到类的加载过程，后面的过程全是虚拟机主导的。\nlinking(链接),链接这一步包含3个步骤\nVerfication(验证) 验证是为了保证class文件安全，不会产生危害JVM的安全，存粹的java语言是不会产生不安全的操作的，比如访问数组边界外的数据，跳转到不存在的代码。但是JVM没有要求class文件的产生途径，我们甚至可以用16进制文本编辑器来编写java文件。所以验证时很重要的，具体的验证规则和验证的时机是直到JDK1.7的JAVA虚拟机规范才具体起来的。\nPreparation(准备) 这个阶段会正式为类变量分配内存并且设定初始值，需要注意的是这里只分配了类变量(static修饰的)，实例变量是没有分配的(实例变量会在初始化时一起分配在堆中)。还有就是类变量一开始会被分配为默认值，实际赋值是在编译后的(这个方法是类的构造方法，收集类的信息，比静态变量值)方法中。比如\nstatic int num = 123;\n那么在准备阶段会被分配为0，在初始化时才会被分配为123。但也有特殊，常量(static final)则会直接被初始化为指定的值。\nResolution(解析) 解析是将常量池中的符号引用替换为直接引用的过程。符号引用是一组描述被引用目标的符号，可以是任何形式的字面量，引用的目标不一定要存在于内存中。直接引用则是指针，相对偏移量或者句柄，直接引用一般是和虚拟机内存布局相关的。\nInitialization(初始化) 初始化是类加载过程的最后一步，到了初始化阶段，就是实际执行程序员编写的代码的步骤。初始化阶段主要是执行方法。JVM会保证父类的方法优先于子类执行，而且多线程环境下也会保证线程安全，当多个线程初始化一个类时，则会只有一个线程去执行方法，这意味着当静态代码块中有比较耗时的操作时，在多线程初始化时有可能造成阻塞。 clinit是将所有的类变量(静态变量)和静态语句(static代码块)的代码合并收集来的。收集的顺序是按照代码顺序，需要注意的是静态代码块的只能访问定义在它之前的静态变量，定义在它之后的变量可以赋值，但是不能访问。再额外说一下，类变量必须有赋值才会被收集为clinit方法，如果只是声明了类变量,比如static int a;那么这个类其实不会生成clinit方法，常量也不会被收集到clinit方法。\nUsing(使用)\nUnloading(卸载)\n一般的加载顺序是按照这五步进行的。需要注意的是，为了支持JAVA语言的运行时绑定，解析的 步骤有可能在初始化之后，这种操作一般被称为动态绑定或者晚绑定。而且，加载类的时机JVM也没规定，但是规定了初始化必须在加载之后，即加载，验证，准备必须在初始化之前。而且严格规定了初始化的执行时机，总共6种，且只有这六种。其他的时机JVM可以自己定义。\n读取到new指令，访问静态final字段时 使用refect包对类进行反射时，如果类没有初始化一定要先初始化 初始化一个类时，如果父类没有初始化先初始化父类(这条规则对接口无效，接口则是允许不初始化父接口，只有使用到父接口时才初始化) JVM启动时必须指定主类，这个主类必须最先初始化 JDK1.7下的Invoke.MethodHandler解析出的类没有经过初始化必须先初始化 JDK1.8以后得接口里使用了default方法时，如果这个接口的实现类发生了变化，那么该接口要在类被初始化之前初始化 举一个简单的例子\n父类\n子类\n下面的代码在执行的时候只会输出&quot;superclass init&quot;，因为只有父类是被初始化了的，虽然是静态引用，但是父类也会初始化。静态变量在编译器编译完成阶段就会被加载到当前类的常量池中，完成和引用类的解耦，这里会初始化存粹是因为父类需要初始化。配合这个例子大家可以看一下TestClass2,TestClass3的代码，思考下为什么。\n"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='http://localhost:1313/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/cover.jpg' />
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/javashitu_hu_4b8114d532ed8b7b.jpg" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">javashitu</a></h1>
            <h2 class="site-description">退笔如山未足珍，读书万卷始通神</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/javashitu'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://space.bilibili.com/1825238836'
                        target="_blank"
                        title="Bilibili"
                        rel="me"
                    >
                        
                        
                            <?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><defs><style>.a{fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;}</style></defs><rect class="a" x="6.1336" y="9.4032" width="35.7327" height="26.5581" rx="6.7532"/><line class="a" x1="17.4835" y1="4.5" x2="20.4078" y2="9.4032"/><line class="a" x1="13.2594" y1="21.6849" x2="20.0829" y2="18.9592"/><line class="a" x1="30.5165" y1="4.5" x2="27.5922" y2="9.4032"/><line class="a" x1="34.7406" y1="21.6849" x2="27.9171" y2="18.9592"/><path class="a" d="M29.0544,24.9161c-.5827,1.4721-1.1508,2.54-2.5273,2.54-1.074,0-1.666-.4976-2.5271-1.8363-.8611,1.3387-1.4531,1.8363-2.5271,1.8363-1.3765,0-1.9446-1.0682-2.5273-2.54"/><path class="a" d="M25.9676,35.9613v2.033s8.6917.2889,8.6917,5.5057H13.3407c0-5.2168,8.6917-5.5057,8.6917-5.5057v-2.033"/></svg>
                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>友情链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="http://localhost:1313/en/" >English</option>
                                
                                    <option value="http://localhost:1313/" selected>中文</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#类加载步骤">类加载步骤</a></li>
    <li><a href="#类加载器"><strong>类加载器</strong></a></li>
    <li><a href="#双亲委派模型">双亲委派模型</a>
      <ol>
        <li><a href="#打破双亲委派规则">打破双亲委派规则</a></li>
      </ol>
    </li>
    <li><a href="#类加载实例">类加载实例</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">
                <img src="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/cover_hu_f83b34c2e0e54e5f.jpg"
                        srcset="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/cover_hu_f83b34c2e0e54e5f.jpg 800w, /p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/cover_hu_a7358337f47cbf5f.jpg 1600w"
                        width="800" 
                        height="514" 
                        loading="lazy"
                        alt="Featured image of post jvm类加载器" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/jvm/" >
                Jvm
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">jvm类加载器</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-4-4</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                
                <time class="article-time--reading">
                    
                    29min
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="学习背景">学习背景
</h1><p>关于垃圾回收器的知识我们讲完了，今天开始我们讲一个JVM里也很重要的概念，类加载器。类加载器可以说是JVM的入口也不为过，而且是面试里非常高频的问点，可以和垃圾回收器并列。几乎是把把问的程度，大家要好好看好好学。</p>
<h2 id="类加载步骤">类加载步骤
</h2><p>我们可以从类的加载步骤来考察类加载器的功能，类从进入JVM内存开始到卸载，生命周期总共经过5步</p>
<ol>
<li>
<p>loading(加载) 这一步需要做的是通过类的全限定名称获取类的二进制流，将字节流所代表的静态存储结构转换为方法区的运行时数据结构，在方法区中生成这个类的class对象，作为方法区中这个类的各种数据的访问入口。也正是因为这一步没有规定读取二进制流的来源是什么，因此诞生了很多后续的技术，比如从压缩包中读取，就变成了JAR,WAR,EAR等格式，从网络中读取就发展成了Applet(运行在浏览器中的java程序，已经被淘汰)，还有JSP,和一些中间件服务器。最有生命力的则是动态代理技术。 而且，也只有这个阶段用户可以自定义一些操作来参与到类的加载过程，后面的过程全是虚拟机主导的。</p>
</li>
<li>
<p>linking(链接),链接这一步包含3个步骤</p>
<ul>
<li>
<p>Verfication(验证) 验证是为了保证class文件安全，不会产生危害JVM的安全，存粹的java语言是不会产生不安全的操作的，比如访问数组边界外的数据，跳转到不存在的代码。但是JVM没有要求class文件的产生途径，我们甚至可以用16进制文本编辑器来编写java文件。所以验证时很重要的，具体的验证规则和验证的时机是直到JDK1.7的JAVA虚拟机规范才具体起来的。</p>
</li>
<li>
<p>Preparation(准备) 这个阶段会正式为类变量分配内存并且设定初始值，需要注意的是这里只分配了类变量(static修饰的)，实例变量是没有分配的(实例变量会在初始化时一起分配在堆中)。还有就是类变量一开始会被分配为默认值，实际赋值是在编译后的<clinit>(这个方法是类的构造方法，收集类的信息，比静态变量值)方法中。比如</p>
<blockquote>
<p>static int num = 123;</p></blockquote>
<p>那么在准备阶段会被分配为0，在初始化时才会被分配为123。但也有特殊，常量(static final)则会直接被初始化为指定的值。</p>
</li>
<li>
<p>Resolution(解析) 解析是将常量池中的符号引用替换为直接引用的过程。符号引用是一组描述被引用目标的符号，可以是任何形式的字面量，引用的目标不一定要存在于内存中。直接引用则是指针，相对偏移量或者句柄，直接引用一般是和虚拟机内存布局相关的。</p>
</li>
</ul>
</li>
<li>
<p>Initialization(初始化) 初始化是类加载过程的最后一步，到了初始化阶段，就是实际执行程序员编写的代码的步骤。初始化阶段主要是执行<clinit>方法。JVM会保证父类的<clinit>方法优先于子类执行，而且多线程环境下也会保证线程安全，当多个线程初始化一个类时，则会只有一个线程去执行<clinit>方法，这意味着当静态代码块中有比较耗时的操作时，在多线程初始化时有可能造成阻塞。 clinit是将所有的类变量(静态变量)和静态语句(static代码块)的代码合并收集来的。收集的顺序是按照代码顺序，需要注意的是静态代码块的只能访问定义在它之前的静态变量，定义在它之后的变量可以赋值，但是不能访问。再额外说一下，类变量必须有赋值才会被收集为clinit方法，如果只是声明了类变量,比如static int a;那么这个类其实不会生成clinit方法，常量也不会被收集到clinit方法。</p>
</li>
</ol>
<p><img src="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404150930595.jpg"
	width="3100"
	height="1584"
	srcset="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404150930595_hu_1310040038964690.jpg 480w, /p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404150930595_hu_ea19d59572b0a328.jpg 1024w"
	loading="lazy"
	
		alt="image-20240404150930595"
	
	
		class="gallery-image" 
		data-flex-grow="195"
		data-flex-basis="469px"
	
></p>
<ol start="4">
<li>
<p>Using(使用)</p>
</li>
<li>
<p>Unloading(卸载)</p>
</li>
</ol>
<p><img src="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%AD%A5%E9%AA%A4.jpg"
	width="1379"
	height="620"
	srcset="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%AD%A5%E9%AA%A4_hu_8ac7e0733e8cd65e.jpg 480w, /p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%AD%A5%E9%AA%A4_hu_a16d5030f40571f7.jpg 1024w"
	loading="lazy"
	
		alt="类加载步骤"
	
	
		class="gallery-image" 
		data-flex-grow="222"
		data-flex-basis="533px"
	
></p>
<p>一般的加载顺序是按照这五步进行的。需要注意的是，为了支持JAVA语言的运行时绑定，解析的 步骤有可能在初始化之后，这种操作一般被称为动态绑定或者晚绑定。而且，加载类的时机JVM也没规定，但是规定了初始化必须在加载之后，即加载，验证，准备必须在初始化之前。而且严格规定了初始化的执行时机，总共6种，且只有这六种。其他的时机JVM可以自己定义。</p>
<ol>
<li>读取到new指令，访问静态final字段时</li>
<li>使用refect包对类进行反射时，如果类没有初始化一定要先初始化</li>
<li>初始化一个类时，如果父类没有初始化先初始化父类(这条规则对接口无效，接口则是允许不初始化父接口，只有使用到父接口时才初始化)</li>
<li>JVM启动时必须指定主类，这个主类必须最先初始化</li>
<li>JDK1.7下的Invoke.MethodHandler解析出的类没有经过初始化必须先初始化</li>
<li>JDK1.8以后得接口里使用了default方法时，如果这个接口的实现类发生了变化，那么该接口要在类被初始化之前初始化</li>
</ol>
<p>举一个简单的例子</p>
<p>父类</p>
<p><img src="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404150957280.jpg"
	width="3106"
	height="1456"
	srcset="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404150957280_hu_28ff1ff27250df4c.jpg 480w, /p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404150957280_hu_89d8aa519ec8321e.jpg 1024w"
	loading="lazy"
	
		alt="image-20240404150957280"
	
	
		class="gallery-image" 
		data-flex-grow="213"
		data-flex-basis="511px"
	
></p>
<p>子类</p>
<p><img src="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404151015366.jpg"
	width="2960"
	height="1304"
	srcset="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404151015366_hu_5c6d9eeea0b5b389.jpg 480w, /p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404151015366_hu_27e80c407c035f1c.jpg 1024w"
	loading="lazy"
	
		alt="image-20240404151015366"
	
	
		class="gallery-image" 
		data-flex-grow="226"
		data-flex-basis="544px"
	
></p>
<p>下面的代码在执行的时候只会输出&quot;superclass init&quot;，因为只有父类是被初始化了的，虽然是静态引用，但是父类也会初始化。静态变量在编译器编译完成阶段就会被加载到当前类的常量池中，完成和引用类的解耦，这里会初始化存粹是因为父类需要初始化。配合这个例子大家可以看一下TestClass2,TestClass3的代码，思考下为什么。</p>
<p><img src="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404151039685.jpg"
	width="3066"
	height="1180"
	srcset="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404151039685_hu_603a2060ff0873c1.jpg 480w, /p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404151039685_hu_768bedb0e9137987.jpg 1024w"
	loading="lazy"
	
		alt="image-20240404151039685"
	
	
		class="gallery-image" 
		data-flex-grow="259"
		data-flex-basis="623px"
	
></p>
<h2 id="类加载器"><strong>类加载器</strong>
</h2><p>上面我们介绍了类加载的步骤，让我们概括一下类加载器的职责。在类的加载阶段，通过类的全限定名区获取类的二进制字节流，实现这个功能的代码就是类加载器。类加载器在osgi，代码热部署，代码加密等领域大放溢彩。</p>
<p>虽然类加载只作用在加载阶段，但是它起到的作用不仅仅在加载阶段。对于任意一个类，都需要加载这个类的类加载器和这个类本身在JVM中确立唯一性。通俗的说，两个类是否相等，取决于两个类是否是同一个类加载器加载，否则就算是同一个路径下的Class文件，在同一个虚拟机中被加载，也被视作不同的类。这里说的两个类是否相等，包括equals()的返回值，instanceOf判断，isInstance()的返回值等等。所以这个规定也影响到equals(),instanceOf等方法的返回结果。这里我给一个例子可以查看代码ClassLoaderTest，自定义类加载器，然后创建出自己，在用创建出的类实例判断是否instanceof自己，返回false。</p>
<p><img src="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404151125588.jpg"
	width="3438"
	height="1856"
	srcset="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404151125588_hu_3add46740bf03f06.jpg 480w, /p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404151125588_hu_a88c5478670c03ca.jpg 1024w"
	loading="lazy"
	
		alt="image-20240404151125588"
	
	
		class="gallery-image" 
		data-flex-grow="185"
		data-flex-basis="444px"
	
></p>
<p>上面的例子虽然简单，但是也足够说明类加载器的功能了。那么什么时候需要自定义类加载器呢，常见的有3种情况</p>
<ol>
<li>加密解密，java代码很容易被反编译，但是可以通过某些算法将java代码加密，然后自己实现类加载器，在类加载器中解密</li>
<li>从非标准源读取类，比如字节码不是在磁盘中，而是数据库甚至网络中，就可以自定义加载指定源的类加载器</li>
<li>动态创建类，实现类的热更新，比如OSGI（开放网关协议）</li>
</ol>
<h2 id="双亲委派模型">双亲委派模型
</h2><p>类加载器是JVM的一个工作模块，JVM中会存在多个类加载器，如果将这些类加载器按照某些规则排序，比如按照加载类的优先级来排序，我们就得到了一个类加载器的层次优先级，这个优先级模型就被称为双亲委派模型。 从虚拟机角度看，只有两种classLoader，启动类加载器Bootstrap ClassLoader（C++实现，有的由纯java语言实现的虚拟机则是用java实现的这个类加载器），另一种就是所有其他类加载器。类加载器工作在创建对象的加载步骤（创建对象总共3步，加载，链接，初始化）</p>
<p>从开发人员角度看，有3中类加载器</p>
<p><img src="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.jpg"
	width="1404"
	height="1040"
	srcset="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B_hu_9ec6739fdd548684.jpg 480w, /p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B_hu_e0b76a1db6b04364.jpg 1024w"
	loading="lazy"
	
		alt="双亲委派模型"
	
	
		class="gallery-image" 
		data-flex-grow="135"
		data-flex-basis="324px"
	
></p>
<ul>
<li>启动类加载器Bootstrap ClassLoader，负责加载JAVA_HOME/lib目录下的类到虚拟机。启动类加载器无法被java程序直接引用。如果需要使用启动类加载器，在自定义classloader的getClassLoader方法里直接return null即可。当然一般我们不会这么做因为这么做就相当于没有自定义Classloader了，一般是用在根据某些条件获取不到ClassLoader时使用启动类加载器来兜底</li>
</ul>
<p><img src="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404152631335.jpg"
	width="2852"
	height="1242"
	srcset="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404152631335_hu_101730b08c08a69.jpg 480w, /p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404152631335_hu_d4a8e35109ec94c2.jpg 1024w"
	loading="lazy"
	
		alt="image-20240404152631335"
	
	
		class="gallery-image" 
		data-flex-grow="229"
		data-flex-basis="551px"
	
></p>
<ul>
<li>扩展类加载器Extension ClassLoader,它负责加载JAVA_HOME/lib/ext目录下或者被java.ext.dirs系统变量指定的路径中的所有类库。开发者可以直接使用这个类加载器。</li>
<li>应用类加载器Appliaction ClassLoader。这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，一般也称为系统类加载器。它负责加载用户路径ClassPath上指定的所有类库。如果系统没有自定义类加载器，那么这个加载器就是默认的类加载器。</li>
</ul>
<p>应用程序都是由这三种类加载器之间互相配合完成的，有需要就可以自定义类加载器。</p>
<p>所谓双亲委派模型就是指这些类加载器之间的层次关系，除了启动类加载器，所有其他类加载器都有自己的父类加载器，这里的类加载器关系一般都由组合而不是继承的方式来复用父类加载器的代码。</p>
<p>双亲委派模型的工作过程是：如果一个类加载收到了类加载请求，她不会自己去加载这个类，而是把这个请求交给父类加载器去完成，这个请求会被传递一直到顶层的启动类加载器。只有当父类加载器不能完成加载请求（他的搜索范围内没有找到需要的类）时，子类加载器才回去加载。当然这是一个理论描述，我们可以从代码角度去观察，实际实现就是在ClassLoader的laodClass方法内，可以看到，首先会检查父类加载器parent存不存在，存在就使用父类加载器加载。</p>
<p><img src="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/2023-06-26-11-05-04-image-2213535.jpg"
	width="3390"
	height="1382"
	srcset="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/2023-06-26-11-05-04-image-2213535_hu_4c635fae1dd8267c.jpg 480w, /p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/2023-06-26-11-05-04-image-2213535_hu_5d302139e00d643c.jpg 1024w"
	loading="lazy"
	
		alt="img"
	
	
		class="gallery-image" 
		data-flex-grow="245"
		data-flex-basis="588px"
	
></p>
<p>使用双亲委派模型的好处是所有类都具备一种优先的层次关系。比如Object，无论哪个类加载加载这个类，最终都是委派给处于模型最顶端的启动类加载器加载，也就是同一个类。如果不是同一个类，java体系中最基本的行为就得不到保证。</p>
<p>自定义类加载器</p>
<p>自定义类加载器，其实就是继承ClassLoader并且重写findClass方法。这里我自定义的类加载器功能是从指定目录读取class文件的字节流。</p>
<p><img src="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404152936528.jpg"
	width="3296"
	height="1750"
	srcset="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404152936528_hu_e288878d7788b7c.jpg 480w, /p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404152936528_hu_ea599b65d9a6520f.jpg 1024w"
	loading="lazy"
	
		alt="image-20240404152936528"
	
	
		class="gallery-image" 
		data-flex-grow="188"
		data-flex-basis="452px"
	
></p>
<p>通过调用自定义类加载器并且通过反射创建出指定的对象，并且执行方法</p>
<p><img src="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404153017758.jpg"
	width="3528"
	height="1662"
	srcset="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404153017758_hu_b6de77b6f409728b.jpg 480w, /p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20240404153017758_hu_b8c194713493bf45.jpg 1024w"
	loading="lazy"
	
		alt="image-20240404153017758"
	
	
		class="gallery-image" 
		data-flex-grow="212"
		data-flex-basis="509px"
	
></p>
<h3 id="打破双亲委派规则">打破双亲委派规则
</h3><p>所谓打破双亲委派规则，就是改变我们之前说的，总是由父类加载器优先去加载类实例。</p>
<p>类加载器一开始的自定义方法是覆盖loadClass方法，现在则是重写findclass方法，其实findClass方法也是在laodClass方法里调用的的。在loadClass方法内，如果父类加载获取不到class,就会调用findClass方法。这就是双亲委派模型的工作方式。如果需要打破这个模型，其实就是重写loadClass方法。这里我不举例子，大家知道怎么做即可。</p>
<p><img src="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20230626114132707-2213535.jpg"
	width="3398"
	height="1614"
	srcset="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20230626114132707-2213535_hu_d79a2bd2ed1b3ced.jpg 480w, /p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/image-20230626114132707-2213535_hu_8d44d57c6efa5676.jpg 1024w"
	loading="lazy"
	
		alt="image-20230626114132707"
	
	
		class="gallery-image" 
		data-flex-grow="210"
		data-flex-basis="505px"
	
></p>
<p>双亲委派模型历史上出现过3次被打破的情况，分别是</p>
<ol>
<li>JDK1.2之前自己打破双亲委派模型 原因是类加载器是从JDK1.0开始就存在的，但是双亲委派模型是JDK1.2引入的，在双亲委派模型出现之前自定义的类加载器都是重写的laodClass方法，为了兼容这种情况，JDK1.2添加了一个protected的laodClass方法，这样类加载器中就有两个laodClass方法，public的loadClass方法唯一的作用就是调用protected的laodClass。但是原先的1.2之前出现的类加载器已经打破了双亲委派模型。所以1.2之后都是通过重写findClass来完成自定义类加载器的工作。</li>
<li>双亲委派模型的第二次破坏是由双亲委派模型的缺陷决定的。我们知道用户重写的是findClass方法，而比较基础的类则是直接委托给顶层的类加载器加载。那么假设基础的类想要访问用户的代码会怎么样，比如JNDI(JNDI是一个资源查找管理服务，它会查找classPath下实现JNDI提供者的代码)这就要求基础类加载器能够识别出用户自定义的代码。为了解决这个问题，java的团队引入了不太优雅的线程上下文类加载器，这个类加载器通过线程的Thread.setContextClassLoader()，这个类加载器会在线程创建时设置，如果不设置就从父线程继承，如果父线程没有，且全局都没有设置，那么就是用应用类加载器。有了这个加载器，父类加载器就能够在特定的条件下去使用子类加载器加载所需要的SPI代码,而且目前JAVA所有涉及SPI的加载动作都是这样完成的，如jdbc,jce，jaxb,jbi等。但是这明显打破了双亲委派模型的一般性规则(即总是先由父类去加载，父类无法完成再使用子类去完成)</li>
<li>双亲委派模型的第三次破坏则是为了追求动态性(代码热部署，热更新)做出的妥协，在某些场景下关机一次就会产生事故，为了应对这些场景就需要热部署的功能。热部署的解决方案是模块化，模块化在业界的事实标准是OSGI(也被称为JSR-291提案，SUN也有自己的提案但是失败了，提案是有业界大牛提供给jcp,然后由委员会决策通过的)，OSGI技术的关键每个模块独有自己的类加载器，且各个模块之间类加载器互相关联，这就不是原先的双亲委派模型的层级结构，而是网状结构。OSGI的搜索方式很复杂，不做介绍，我们知道有这么个事情即可。</li>
</ol>
<p>打破双亲委派规则是可以的，只要有足够的理由，合理的创新也是值得推荐的。</p>
<h2 id="类加载实例">类加载实例
</h2><p>讲完了类加载器的功能和工作方式，我们再通过几个案例来讲解类加载的时机以及要求。常见的tomcat,jetty,weblogic都实现了自己的类加载器。以tomcat为例，因为TOMCAT使用的是正统且标准的类加载器结构，一个web服务器要解决很多问题，比如</p>
<ol>
<li>部署在一个web服务器下的程序的类库需要互相独立，不能干扰。</li>
<li>多个程序之间如果有相同的类库，必须能复用，因为如果简单地只是每个服务单独加载自己的类库是很浪费资源的。比如两个服务里都使用到了guava包，而且版本一样，那么两个服务最好都加载同一个包。</li>
<li>服务器本身不能受到程序的类库的影响</li>
</ol>
<p>为了实现这些需求，如果是简单的使用应用程序类加载器只读取classpath目录下的类库，很明显会因为类库的冲突发生错误。所以tomcat得做法是划分出多个目录，common,server,shared,加上web程序jar内部自身的web-inf目录，对这些目录分别使用不同的类加载器达到不同的效果，common目录下的类库可以被tomcat和web应用程序公用，server目录下的则可以被tomcat使用，shared目录下类库的可以所有web服务器使用。jar包自身的web-inf目录下的类库则只能被web程序使用。为此tomcat定义了多个类加载器。</p>
<p><img src="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg"
	width="860"
	height="1572"
	srcset="/p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8_hu_7b97070ab76f04fa.jpg 480w, /p/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.assets/tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8_hu_90c206c6ac12b36f.jpg 1024w"
	loading="lazy"
	
		alt="tomcat类加载器"
	
	
		class="gallery-image" 
		data-flex-grow="54"
		data-flex-basis="131px"
	
></p>
<p>额外说一下JSP，虽然已经淘汰了。JSP是每个JSP文件一个JSP类加载器，很操蛋是吧，这也决定了它性能很垃圾。再考虑一种场景，使用sparing开发的程序，使用tomcat部署，spring类库被放在common路径下，但是如果一个tomcat部署了10个spring程序，那么spring是怎么分别获取到这些程序的启动入口的呢？其实就是通过SPI机制配合自定义类加载器完成的，这也是spring的starter的核心原理。</p>
<h1 id="end">END
</h1><p>到这里类加载器的内容就讲完了，类加载器是面试里非常高频的考点，大家一定要好好学。项目里用到的代码可以在公众号上回复8121获取。</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/jvm/">Jvm</a>
        
            <a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">类加载器</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99/">
        
        
            <div class="article-image">
                <img src="/p/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99/index.assets/cover.386e079aa54a6fb6d29a54fd4b0be56f_hu_244f1489af6b6215.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post jvm垃圾回收器对象分配规则"
                        
                        data-hash="md5-OG4HmqVKb7bSmlT9Swvlbw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">jvm垃圾回收器对象分配规则</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%90%8E%E7%AF%87/">
        
        
            <div class="article-image">
                <img src="/p/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%90%8E%E7%AF%87/index.assets/cover.5cfcd04baec36fca4e14911b4f67c751_hu_77cdd67923b433a1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post jvm垃圾回收器后篇"
                        
                        data-hash="md5-XPzQS67Db8pOFJEbT2fHUQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">jvm垃圾回收器后篇</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%89%8D%E7%AF%87/">
        
        
            <div class="article-image">
                <img src="/p/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%89%8D%E7%AF%87/index.assets/cover.d90fa26e1736e1e5528c871b12e50b42_hu_e5afb3c60a0897e9.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post jvm垃圾回收器前篇"
                        
                        data-hash="md5-2Q&#43;ibhc24eVSjIcbEuULQg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">jvm垃圾回收器前篇</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2025 javashitu
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.4c637ef32fb19f6d91a76f6f1f78e08f50dc0096fc75afe065dfd9b68bccd6c0.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
